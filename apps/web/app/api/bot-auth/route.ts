import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const SUPABASE_SERVICE_KEY = process.env.SUPABASE_SERVICE_KEY!;

/**
 * Validates a magic-link token generated by the Telegram bot /login command.
 *
 * POST { token: string }
 * → 200 { valid: true, telegram_id: number, name: string }
 * → 400 { valid: false, error: string }
 */
export async function POST(req: NextRequest) {
  try {
    const { token } = await req.json();

    if (!token || typeof token !== "string") {
      return NextResponse.json({ valid: false, error: "Token requerido" }, { status: 400 });
    }

    const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY);

    const { data, error } = await supabase
      .from("auth_tokens")
      .select("token, telegram_id, name, expires_at, used")
      .eq("token", token)
      .single();

    if (error || !data) {
      return NextResponse.json({ valid: false, error: "Token inválido" }, { status: 400 });
    }

    if (data.used) {
      return NextResponse.json({ valid: false, error: "Este link ya fue utilizado" }, { status: 400 });
    }

    if (new Date(data.expires_at) < new Date()) {
      return NextResponse.json({ valid: false, error: "El link expiró. Escribe /login en el bot para obtener uno nuevo" }, { status: 400 });
    }

    // Mark token as used
    await supabase
      .from("auth_tokens")
      .update({ used: true })
      .eq("token", token);

    return NextResponse.json({
      valid: true,
      telegram_id: data.telegram_id,
      name: data.name,
    });
  } catch (error) {
    console.error("Bot auth error:", error);
    return NextResponse.json({ valid: false, error: "Error interno" }, { status: 500 });
  }
}
